# mdict_tools Swift AI Quickstart

Ultra-compact guide for another AI (or automation agent) to integrate and call this library from Swift.

## 1) Generate Swift package output

Run from repo root:

```bash
./create-framework.sh
```

Use the generated package at:

- `output_framework/SwiftPackage`

In Xcode, add local package dependency pointing to that folder, then:

```swift
import mdict_tools
```

## 2) Core Swift API surface (generated by UniFFI)

Factories:

- `createMdictBundle(mdxPath:mddPath:) -> MdictBundle`
- `createMdictOptimizedFromBundle(bundle:fstPath:readingsPath:recordPath:) -> MdictOptimized`
- `createMdictOptimizedFromBundleWithProgress(bundle:fstPath:readingsPath:recordPath:progressCallback:) -> MdictOptimized`
- `createMdictOptimizedFromFst(fstPath:readingsPath:recordPath:) -> MdictOptimized`

Main types:

- `KeyBlock { keyId: UInt64, keyText: String }`
- `PrefixSearchCursor { afterKey: String }`
- `PrefixSearchPage { results: [KeyBlock], nextCursor: PrefixSearchCursor?, totalResults: UInt64? }`
- `BuildProgressStage`: `start`, `buildReadings`, `buildFst`, `done`
- `BuildProgressCallback` protocol: `onProgress(stage:completed:total:)`
- `MDictError` (thrown): `Io`, `InvalidFormat`, `InvalidArgument`, `KeyNotFound`, `UnsupportedFeature`

## 3) Usage pattern (recommended)

1. Open source dictionary once with `MdictBundle`.
2. Build FST assets once with `createMdictOptimizedFromBundle(...)`.
3. On later app launches, skip rebuild and open directly with `createMdictOptimizedFromFst(...)`.

### Build + open optimized index

```swift
let bundle = try createMdictBundle(
    mdxPath: "/abs/path/dict.mdx",
    mddPath: "/abs/path/dict.mdd"
)

let optimized = try createMdictOptimizedFromBundle(
    bundle: bundle,
    fstPath: "/abs/path/fst_index.fst",
    readingsPath: "/abs/path/fst_index_values.txt",
    recordPath: "/abs/path/record_data.bin"
)
```

### Build + open optimized index with progress callback

```swift
final class BuildProgress: BuildProgressCallback {
    func onProgress(stage: BuildProgressStage, completed: UInt64, total: UInt64) {
        print("stage=\(stage) progress=\(completed)/\(total)")
    }
}

let optimized = try createMdictOptimizedFromBundleWithProgress(
    bundle: bundle,
    fstPath: "/abs/path/fst_index.fst",
    readingsPath: "/abs/path/fst_index_values.txt",
    recordPath: "/abs/path/record_data.bin",
    progressCallback: BuildProgress()
)
```

### Reopen existing optimized assets

```swift
let optimized = try createMdictOptimizedFromFst(
    fstPath: "/abs/path/fst_index.fst",
    readingsPath: "/abs/path/fst_index_values.txt",
    recordPath: "/abs/path/record_data.bin"
)
```

## 4) Prefix search paging (no full-result materialization)

```swift
let first = try optimized.setSearchPrefixPaged(prefix: "食", pageSize: 50)
for key in first.results {
    let bytes = try optimized.recordAt(keyBlock: key)
    let html = String(data: bytes, encoding: .utf8) ?? ""
    _ = html
}

var cursor = first.nextCursor
while let c = cursor {
    let page = try optimized.prefixSearchNextPage(cursor: c)
    for key in page.results {
        let bytes = try optimized.recordAt(keyBlock: key)
        let html = String(data: bytes, encoding: .utf8) ?? ""
        _ = html
    }
    cursor = page.nextCursor
}
```

Notes:

- Cursor token is key-based (`afterKey`), not offset-based.
- `totalResults` can be `nil` (unknown/not computed for some calls).

## 5) Legacy (bundle-only) search pattern

```swift
try bundle.setSearchPrefix(prefix: "食")
var i: UInt64 = 0
while let key = try bundle.prefixSearchResultGet(index: i) {
    let data = try bundle.recordAt(keyBlock: key)
    let text = String(data: data, encoding: .utf8) ?? ""
    _ = text
    i += 1
}
```

## 6) Important correctness detail

Do not assume optimized `keyId` equals legacy MDX index id. Use `keyText` for cross-comparison between `MdictOptimized` and `MdictBundle` results.

## 7) After API changes

If callback symbols are missing in Swift, regenerate bindings/package:

```bash
./create-framework.sh
```
